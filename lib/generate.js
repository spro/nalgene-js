// Generated by CoffeeScript 1.12.7
var VERBOSE, asSentence, bestMatch, contextAsString, expandTokens, flatten, generate, listKeys, listValues, minimist, parse, randomChoice, ref, scoreKey, splitToken,
  slice = [].slice;

minimist = require('minimist');

ref = require('./helpers'), randomChoice = ref.randomChoice, flatten = ref.flatten, splitToken = ref.splitToken, asSentence = ref.asSentence;

parse = require('./parse');

VERBOSE = false;

listKeys = function(list) {
  var j, l, len, results;
  results = [];
  for (j = 0, len = list.length; j < len; j++) {
    l = list[j];
    results.push(l[0]);
  }
  return results;
};

listValues = function(list) {
  var j, l, len, results;
  results = [];
  for (j = 0, len = list.length; j < len; j++) {
    l = list[j];
    results.push(l[1]);
  }
  return results;
};

bestMatch = function(child_keys, context) {
  var child, child_key, context_keys, j, len, score;
  for (j = 0, len = child_keys.length; j < len; j++) {
    child_key = child_keys[j];
    context_keys = (function() {
      var k, len1, ref1, results;
      ref1 = context.children;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        child = ref1[k];
        results.push(child.key);
      }
      return results;
    })();
    score = scoreKey(child_key, context_keys);
    if (score === 0) {
      return [child_key, context.children];
    }
  }
  return [null, null];
};

scoreKey = function(child_key, context_keys) {
  var cc, child_phrases, child_tokens, ci;
  if (VERBOSE) {
    console.log('[scoreKey]', child_key, context_keys);
  }
  child_tokens = child_key.split(' ');
  child_phrases = child_tokens.filter(function(t) {
    var ref1;
    return (ref1 = t[0]) === '%' || ref1 === '$';
  });
  while (context_keys.length) {
    cc = context_keys.shift();
    ci = child_phrases.indexOf(cc);
    if (ci === -1) {
      return -1;
    } else {
      child_phrases.splice(ci, 1);
    }
  }
  return child_phrases.length;
};

contextAsString = function(l) {
  if (typeof l === 'string') {
    return l;
  } else {
    return JSON.stringify(l);
    return group(l).map(function(g) {
      return g.map(contextAsString).join(': ');
    }).join(', ');
  }
};

module.exports = generate = function(root, entry_key, context, options) {
  var best_match, child, child_keys, contexts, entry, expandable, expanded, i, j, len, ref1, ref2, sub_context, synonym, token;
  if (entry_key == null) {
    entry_key = '%';
  }
  if (context == null) {
    context = {};
  }
  if (options == null) {
    options = {};
  }
  if (VERBOSE) {
    console.log('\n[generate]', 'entry =', entry_key, 'context =', context);
  }
  entry = root.get(entry_key);
  if (entry == null) {
    throw new Error('No such phrase on root: ' + entry_key);
  }
  child_keys = (function() {
    var j, len, ref1, results;
    ref1 = entry.children;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      child = ref1[j];
      results.push(child.key);
    }
    return results;
  })();
  ref1 = bestMatch(child_keys, context), best_match = ref1[0], contexts = ref1[1];
  if (best_match == null) {
    throw new Error("No best match for " + entry_key + " with context " + (contextAsString(context)));
    process.exit(0);
  }
  expanded = [];
  expandable = best_match.split(' ').filter(function(t) {
    var ref2;
    return (ref2 = t[0]) === '%' || ref2 === '$';
  });
  ref2 = best_match.split(' ');
  for (j = 0, len = ref2.length; j < len; j++) {
    token = ref2[j];
    i = expandable.indexOf(token);
    if (i > -1) {
      expandable[i] = 'EXPANDED';
      sub_context = contexts[i];
      if (token[0] === '%') {
        expanded.push(generate(root, token, sub_context, options));
      } else {
        expanded.push(sub_context.children);
      }
    } else {
      if (token[0] === '~') {
        if (token.match(/\?$/)) {
          if (Math.random() < 0.5) {
            continue;
          } else {
            token = token.slice(0, -1);
          }
        }
        synonym = root.get(token);
        expanded.push(synonym.randomLeaf().key);
      } else {
        expanded.push(token);
      }
    }
  }
  return expanded;
};

expandTokens = function(tokens, root, context) {
  var chosen_synonym, chosen_synonyms, expanded, g, given, j, k, len, len1, pruned_synonym, ref1, sub_phrase, sub_tokens, synonym, synonym_tokens, token;
  if (VERBOSE) {
    console.log('[expandTokens]', tokens);
  }
  expanded = [];
  chosen_synonyms = {};
  for (j = 0, len = tokens.length; j < len; j++) {
    token = tokens[j];
    if (token.match(/^\$/)) {
      expanded.push(context[token]);
    } else if (token.match(/^~/)) {
      if (token.match(/\?$/)) {
        if (Math.random() < 0.5) {
          continue;
        } else {
          token = token.slice(0, -1);
        }
      }
      synonym = root.get(token);
      if (!synonym) {
        throw new Error('No such synonym on root: ' + token);
      }
      pruned_synonym = synonym.prune(chosen_synonyms[token]);
      if (pruned_synonym.children.length === 0) {
        pruned_synonym = synonym;
        delete chosen_synonyms[token];
      }
      chosen_synonym = pruned_synonym.randomLeaf().key;
      chosen_synonyms[token] || (chosen_synonyms[token] = []);
      chosen_synonyms[token].push(chosen_synonym);
      synonym_tokens = chosen_synonym.split(' ');
      expanded = expanded.concat(expandTokens(synonym_tokens, root, context));
    } else if (token.match(/^#/)) {
      ref1 = token.split('|'), token = ref1[0], given = 2 <= ref1.length ? slice.call(ref1, 1) : [];
      sub_phrase = root.get(token);
      if (sub_phrase == null) {
        throw new Error('No such hash on root: ' + token);
      }
      if (!given.length) {
        throw new Error('No values given for hash: ' + token);
      }
      for (k = 0, len1 = given.length; k < len1; k++) {
        g = given[k];
        if (g.match(/^\$/)) {
          sub_phrase = sub_phrase.get(context[g]);
        } else {
          sub_phrase = sub_phrase.get(g);
        }
        if (sub_phrase == null) {
          throw new Error('No such value on hash: ' + token + '|' + given.map(function(g) {
            return context[g];
          }).join('|'));
        }
      }
      sub_tokens = sub_phrase.randomLeaf().key.split(' ');
      expanded = expanded.concat(expandTokens(sub_tokens, root, context));
    } else {
      expanded.push(token);
    }
  }
  return expanded;
};

module.exports.fromPlainString = function(string, context) {
  var root;
  root = parse.fromObject({
    '%': string
  });
  return generate(root, context);
};
